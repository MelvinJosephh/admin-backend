{
  "version": 3,
  "sources": ["../../../../../node_modules/rxfire/storage/index.esm.js", "../../../../../node_modules/@angular/fire/fesm2022/angular-fire-storage.mjs"],
  "sourcesContent": ["import { getDownloadURL as getDownloadURL$1, getMetadata as getMetadata$1, uploadBytesResumable as uploadBytesResumable$1, uploadString as uploadString$1 } from 'firebase/storage';\nimport { Observable, from } from 'rxjs';\nimport { shareReplay, map } from 'rxjs/operators';\nfunction fromTask(task) {\n  return new Observable(function (subscriber) {\n    var lastSnapshot = null;\n    var complete = false;\n    var hasError = false;\n    var error = null;\n    var emit = function (snapshot) {\n      lastSnapshot = snapshot;\n      schedule();\n    };\n    var id = null;\n    /**\n     * Schedules an async event to check and emit\n     * the most recent snapshot, and complete or error\n     * if necessary.\n     */\n    var schedule = function () {\n      if (!id) {\n        id = setTimeout(function () {\n          id = null;\n          if (lastSnapshot) subscriber.next(lastSnapshot);\n          if (complete) subscriber.complete();\n          if (hasError) subscriber.error(error);\n        });\n      }\n    };\n    subscriber.add(function () {\n      // If we have any emissions checks scheduled, cancel them.\n      if (id) clearTimeout(id);\n    });\n    // Emit the initial snapshot\n    emit(task.snapshot);\n    // Take each update and schedule them to be emitted (see `emit`)\n    subscriber.add(task.on('state_changed', emit));\n    // task is a promise, so we can convert that to an observable,\n    // this is done for the ergonomics around making sure we don't\n    // try to push errors or completions through closed subscribers\n    subscriber.add(from(task).subscribe({\n      next: emit,\n      error: function (err) {\n        hasError = true;\n        error = err;\n        schedule();\n      },\n      complete: function () {\n        complete = true;\n        schedule();\n      }\n    }));\n  });\n}\nfunction getDownloadURL(ref) {\n  return from(getDownloadURL$1(ref));\n}\n// TODO: fix storage typing in firebase, then apply the same fix here\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction getMetadata(ref) {\n  return from(getMetadata$1(ref));\n}\n// MARK: Breaking change (renaming put to uploadBytesResumable)\nfunction uploadBytesResumable(ref, data, metadata) {\n  return new Observable(function (subscriber) {\n    var task = uploadBytesResumable$1(ref, data, metadata);\n    var subscription = fromTask(task).subscribe(subscriber);\n    return function unsubscribe() {\n      subscription.unsubscribe();\n      task.cancel();\n    };\n  }).pipe(shareReplay({\n    bufferSize: 1,\n    refCount: true\n  }));\n}\n// MARK: Breaking change (renaming put to uploadString)\nfunction uploadString(ref, data, format, metadata) {\n  return from(uploadString$1(ref, data, format, metadata));\n}\nfunction percentage(task) {\n  return fromTask(task).pipe(map(function (snapshot) {\n    return {\n      progress: snapshot.bytesTransferred / snapshot.totalBytes * 100,\n      snapshot: snapshot\n    };\n  }));\n}\nexport { fromTask, getDownloadURL, getMetadata, percentage, uploadBytesResumable, uploadString };\n", "import { ɵgetAllInstancesOf as _getAllInstancesOf, ɵgetDefaultInstanceOf as _getDefaultInstanceOf, VERSION, ɵAngularFireSchedulers as _AngularFireSchedulers, ɵAppCheckInstances as _AppCheckInstances, ɵzoneWrap as _zoneWrap } from '@angular/fire';\nimport { timer, from } from 'rxjs';\nimport { concatMap, distinct } from 'rxjs/operators';\nimport * as i0 from '@angular/core';\nimport { InjectionToken, Optional, NgModule, makeEnvironmentProviders, NgZone, Injector } from '@angular/core';\nimport { FirebaseApp, FirebaseApps } from '@angular/fire/app';\nimport { AuthInstances } from '@angular/fire/auth';\nimport { registerVersion } from 'firebase/app';\nimport { fromTask as fromTask$1, percentage as percentage$1 } from 'rxfire/storage';\nimport { connectStorageEmulator as connectStorageEmulator$1, deleteObject as deleteObject$1, getBlob as getBlob$1, getBytes as getBytes$1, getDownloadURL as getDownloadURL$1, getMetadata as getMetadata$1, getStorage as getStorage$1, getStream as getStream$1, list as list$1, listAll as listAll$1, ref as ref$1, updateMetadata as updateMetadata$1, uploadBytes as uploadBytes$1, uploadBytesResumable as uploadBytesResumable$1, uploadString as uploadString$1 } from 'firebase/storage';\nexport * from 'firebase/storage';\nclass Storage {\n  constructor(auth) {\n    return auth;\n  }\n}\nconst STORAGE_PROVIDER_NAME = 'storage';\nclass StorageInstances {\n  constructor() {\n    return _getAllInstancesOf(STORAGE_PROVIDER_NAME);\n  }\n}\nconst storageInstance$ = timer(0, 300).pipe(concatMap(() => from(_getAllInstancesOf(STORAGE_PROVIDER_NAME))), distinct());\nconst PROVIDED_STORAGE_INSTANCES = new InjectionToken('angularfire2.storage-instances');\nfunction defaultStorageInstanceFactory(provided, defaultApp) {\n  const defaultStorage = _getDefaultInstanceOf(STORAGE_PROVIDER_NAME, provided, defaultApp);\n  return defaultStorage && new Storage(defaultStorage);\n}\nfunction storageInstanceFactory(fn) {\n  return (zone, injector) => {\n    const storage = zone.runOutsideAngular(() => fn(injector));\n    return new Storage(storage);\n  };\n}\nconst STORAGE_INSTANCES_PROVIDER = {\n  provide: StorageInstances,\n  deps: [[new Optional(), PROVIDED_STORAGE_INSTANCES]]\n};\nconst DEFAULT_STORAGE_INSTANCE_PROVIDER = {\n  provide: Storage,\n  useFactory: defaultStorageInstanceFactory,\n  deps: [[new Optional(), PROVIDED_STORAGE_INSTANCES], FirebaseApp]\n};\nclass StorageModule {\n  constructor() {\n    registerVersion('angularfire', VERSION.full, 'gcs');\n  }\n  static ɵfac = function StorageModule_Factory(__ngFactoryType__) {\n    return new (__ngFactoryType__ || StorageModule)();\n  };\n  static ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: StorageModule\n  });\n  static ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({\n    providers: [DEFAULT_STORAGE_INSTANCE_PROVIDER, STORAGE_INSTANCES_PROVIDER]\n  });\n}\n(() => {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && i0.ɵsetClassMetadata(StorageModule, [{\n    type: NgModule,\n    args: [{\n      providers: [DEFAULT_STORAGE_INSTANCE_PROVIDER, STORAGE_INSTANCES_PROVIDER]\n    }]\n  }], () => [], null);\n})();\nfunction provideStorage(fn, ...deps) {\n  registerVersion('angularfire', VERSION.full, 'gcs');\n  return makeEnvironmentProviders([DEFAULT_STORAGE_INSTANCE_PROVIDER, STORAGE_INSTANCES_PROVIDER, {\n    provide: PROVIDED_STORAGE_INSTANCES,\n    useFactory: storageInstanceFactory(fn),\n    multi: true,\n    deps: [NgZone, Injector, _AngularFireSchedulers, FirebaseApps,\n    // Defensively load Auth first, if provided\n    [new Optional(), AuthInstances], [new Optional(), _AppCheckInstances], ...deps]\n  }]);\n}\n\n// DO NOT MODIFY, this file is autogenerated by tools/build.ts\nconst fromTask = _zoneWrap(fromTask$1, true);\nconst percentage = _zoneWrap(percentage$1, true);\n\n// DO NOT MODIFY, this file is autogenerated by tools/build.ts\nconst connectStorageEmulator = _zoneWrap(connectStorageEmulator$1, true);\nconst deleteObject = _zoneWrap(deleteObject$1, true);\nconst getBlob = _zoneWrap(getBlob$1, true);\nconst getBytes = _zoneWrap(getBytes$1, true);\nconst getDownloadURL = _zoneWrap(getDownloadURL$1, true);\nconst getMetadata = _zoneWrap(getMetadata$1, true);\nconst getStorage = _zoneWrap(getStorage$1, true);\nconst getStream = _zoneWrap(getStream$1, true);\nconst list = _zoneWrap(list$1, true);\nconst listAll = _zoneWrap(listAll$1, true);\nconst ref = _zoneWrap(ref$1, true);\nconst updateMetadata = _zoneWrap(updateMetadata$1, true);\nconst uploadBytes = _zoneWrap(uploadBytes$1, true);\nconst uploadBytesResumable = _zoneWrap(uploadBytesResumable$1, true);\nconst uploadString = _zoneWrap(uploadString$1, true);\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { Storage, StorageInstances, StorageModule, connectStorageEmulator, deleteObject, fromTask, getBlob, getBytes, getDownloadURL, getMetadata, getStorage, getStream, list, listAll, percentage, provideStorage, ref, storageInstance$, updateMetadata, uploadBytes, uploadBytesResumable, uploadString };\n"],
  "mappings": "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",
  "names": ["fromTask", "percentage", "connectStorageEmulator", "deleteObject", "getBlob", "getBytes", "getDownloadURL", "getMetadata", "getStorage", "getStream", "list", "listAll", "ref", "updateMetadata", "uploadBytes", "uploadBytesResumable", "uploadString"]
}
